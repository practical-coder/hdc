// Code generated by go-swagger; DO NOT EDIT.

package models

// This file was generated by the swagger tool.
// Editing this file might prove futile when you re-run the swagger generate command

import (
	"context"
	"encoding/json"
	"strconv"

	"github.com/go-openapi/errors"
	"github.com/go-openapi/strfmt"
	"github.com/go-openapi/swag"
	"github.com/go-openapi/validate"
)

// HTTPCheckRule HTTP Check Rule
//
// swagger:model http_check_rule
type HTTPCheckRule struct {

	// check headers
	CheckHeaders []*CheckHeader `json:"headers"`

	// action
	// Required: true
	// Enum: [comment connect disable-on-404 expect send send-state set-var unset-var]
	Action string `json:"action"`

	// addr
	// Pattern: ^[^\s]+$
	Addr string `json:"addr,omitempty"`

	// alpn
	// Pattern: ^[^\s]+$
	Alpn string `json:"alpn,omitempty"`

	// body
	Body string `json:"body,omitempty"`

	// body log format
	BodyLogFormat string `json:"body_log_format,omitempty"`

	// check comment
	CheckComment string `json:"check_comment,omitempty"`

	// default
	Default bool `json:"default,omitempty"`

	// error status
	// Enum: [L7OKC L7RSP L7STS L6RSP L4CON]
	ErrorStatus string `json:"error_status,omitempty"`

	// exclamation mark
	ExclamationMark bool `json:"exclamation_mark,omitempty"`

	// index
	// Required: true
	Index *int64 `json:"index"`

	// linger
	Linger bool `json:"linger,omitempty"`

	// match
	// Pattern: ^[^\s]+$
	// Enum: [status rstatus hdr fhdr string rstring]
	Match string `json:"match,omitempty"`

	// method
	Method string `json:"method,omitempty"`

	// min recv
	MinRecv int64 `json:"min_recv,omitempty"`

	// ok status
	// Enum: [L7OK L7OKC L6OK L4OK]
	OkStatus string `json:"ok_status,omitempty"`

	// on error
	OnError string `json:"on_error,omitempty"`

	// on success
	OnSuccess string `json:"on_success,omitempty"`

	// pattern
	Pattern string `json:"pattern,omitempty"`

	// port
	// Maximum: 65535
	// Minimum: 1
	Port *int64 `json:"port,omitempty"`

	// port string
	PortString string `json:"port_string,omitempty"`

	// proto
	Proto string `json:"proto,omitempty"`

	// send proxy
	SendProxy bool `json:"send_proxy,omitempty"`

	// sni
	Sni string `json:"sni,omitempty"`

	// ssl
	Ssl bool `json:"ssl,omitempty"`

	// status code
	StatusCode string `json:"status-code,omitempty"`

	// tout status
	// Enum: [L7TOUT L6TOUT L4TOUT]
	ToutStatus string `json:"tout_status,omitempty"`

	// uri
	URI string `json:"uri,omitempty"`

	// uri log format
	URILogFormat string `json:"uri_log_format,omitempty"`

	// var expr
	VarExpr string `json:"var_expr,omitempty"`

	// var name
	// Pattern: ^[^\s]+$
	VarName string `json:"var_name,omitempty"`

	// var scope
	// Pattern: ^[^\s]+$
	VarScope string `json:"var_scope,omitempty"`

	// version
	Version string `json:"version,omitempty"`

	// via socks4
	ViaSocks4 bool `json:"via_socks4,omitempty"`
}

// Validate validates this http check rule
func (m *HTTPCheckRule) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateCheckHeaders(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAction(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAddr(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateAlpn(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateErrorStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateIndex(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateMatch(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateOkStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validatePort(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateToutStatus(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVarName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateVarScope(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HTTPCheckRule) validateCheckHeaders(formats strfmt.Registry) error {
	if swag.IsZero(m.CheckHeaders) { // not required
		return nil
	}

	for i := 0; i < len(m.CheckHeaders); i++ {
		if swag.IsZero(m.CheckHeaders[i]) { // not required
			continue
		}

		if m.CheckHeaders[i] != nil {
			if err := m.CheckHeaders[i].Validate(formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("headers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("headers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

var httpCheckRuleTypeActionPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["comment","connect","disable-on-404","expect","send","send-state","set-var","unset-var"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		httpCheckRuleTypeActionPropEnum = append(httpCheckRuleTypeActionPropEnum, v)
	}
}

const (

	// HTTPCheckRuleActionComment captures enum value "comment"
	HTTPCheckRuleActionComment string = "comment"

	// HTTPCheckRuleActionConnect captures enum value "connect"
	HTTPCheckRuleActionConnect string = "connect"

	// HTTPCheckRuleActionDisableDashOnDash404 captures enum value "disable-on-404"
	HTTPCheckRuleActionDisableDashOnDash404 string = "disable-on-404"

	// HTTPCheckRuleActionExpect captures enum value "expect"
	HTTPCheckRuleActionExpect string = "expect"

	// HTTPCheckRuleActionSend captures enum value "send"
	HTTPCheckRuleActionSend string = "send"

	// HTTPCheckRuleActionSendDashState captures enum value "send-state"
	HTTPCheckRuleActionSendDashState string = "send-state"

	// HTTPCheckRuleActionSetDashVar captures enum value "set-var"
	HTTPCheckRuleActionSetDashVar string = "set-var"

	// HTTPCheckRuleActionUnsetDashVar captures enum value "unset-var"
	HTTPCheckRuleActionUnsetDashVar string = "unset-var"
)

// prop value enum
func (m *HTTPCheckRule) validateActionEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, httpCheckRuleTypeActionPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *HTTPCheckRule) validateAction(formats strfmt.Registry) error {

	if err := validate.RequiredString("action", "body", m.Action); err != nil {
		return err
	}

	// value enum
	if err := m.validateActionEnum("action", "body", m.Action); err != nil {
		return err
	}

	return nil
}

func (m *HTTPCheckRule) validateAddr(formats strfmt.Registry) error {
	if swag.IsZero(m.Addr) { // not required
		return nil
	}

	if err := validate.Pattern("addr", "body", m.Addr, `^[^\s]+$`); err != nil {
		return err
	}

	return nil
}

func (m *HTTPCheckRule) validateAlpn(formats strfmt.Registry) error {
	if swag.IsZero(m.Alpn) { // not required
		return nil
	}

	if err := validate.Pattern("alpn", "body", m.Alpn, `^[^\s]+$`); err != nil {
		return err
	}

	return nil
}

var httpCheckRuleTypeErrorStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["L7OKC","L7RSP","L7STS","L6RSP","L4CON"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		httpCheckRuleTypeErrorStatusPropEnum = append(httpCheckRuleTypeErrorStatusPropEnum, v)
	}
}

const (

	// HTTPCheckRuleErrorStatusL7OKC captures enum value "L7OKC"
	HTTPCheckRuleErrorStatusL7OKC string = "L7OKC"

	// HTTPCheckRuleErrorStatusL7RSP captures enum value "L7RSP"
	HTTPCheckRuleErrorStatusL7RSP string = "L7RSP"

	// HTTPCheckRuleErrorStatusL7STS captures enum value "L7STS"
	HTTPCheckRuleErrorStatusL7STS string = "L7STS"

	// HTTPCheckRuleErrorStatusL6RSP captures enum value "L6RSP"
	HTTPCheckRuleErrorStatusL6RSP string = "L6RSP"

	// HTTPCheckRuleErrorStatusL4CON captures enum value "L4CON"
	HTTPCheckRuleErrorStatusL4CON string = "L4CON"
)

// prop value enum
func (m *HTTPCheckRule) validateErrorStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, httpCheckRuleTypeErrorStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *HTTPCheckRule) validateErrorStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.ErrorStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateErrorStatusEnum("error_status", "body", m.ErrorStatus); err != nil {
		return err
	}

	return nil
}

func (m *HTTPCheckRule) validateIndex(formats strfmt.Registry) error {

	if err := validate.Required("index", "body", m.Index); err != nil {
		return err
	}

	return nil
}

var httpCheckRuleTypeMatchPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["status","rstatus","hdr","fhdr","string","rstring"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		httpCheckRuleTypeMatchPropEnum = append(httpCheckRuleTypeMatchPropEnum, v)
	}
}

const (

	// HTTPCheckRuleMatchStatus captures enum value "status"
	HTTPCheckRuleMatchStatus string = "status"

	// HTTPCheckRuleMatchRstatus captures enum value "rstatus"
	HTTPCheckRuleMatchRstatus string = "rstatus"

	// HTTPCheckRuleMatchHdr captures enum value "hdr"
	HTTPCheckRuleMatchHdr string = "hdr"

	// HTTPCheckRuleMatchFhdr captures enum value "fhdr"
	HTTPCheckRuleMatchFhdr string = "fhdr"

	// HTTPCheckRuleMatchString captures enum value "string"
	HTTPCheckRuleMatchString string = "string"

	// HTTPCheckRuleMatchRstring captures enum value "rstring"
	HTTPCheckRuleMatchRstring string = "rstring"
)

// prop value enum
func (m *HTTPCheckRule) validateMatchEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, httpCheckRuleTypeMatchPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *HTTPCheckRule) validateMatch(formats strfmt.Registry) error {
	if swag.IsZero(m.Match) { // not required
		return nil
	}

	if err := validate.Pattern("match", "body", m.Match, `^[^\s]+$`); err != nil {
		return err
	}

	// value enum
	if err := m.validateMatchEnum("match", "body", m.Match); err != nil {
		return err
	}

	return nil
}

var httpCheckRuleTypeOkStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["L7OK","L7OKC","L6OK","L4OK"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		httpCheckRuleTypeOkStatusPropEnum = append(httpCheckRuleTypeOkStatusPropEnum, v)
	}
}

const (

	// HTTPCheckRuleOkStatusL7OK captures enum value "L7OK"
	HTTPCheckRuleOkStatusL7OK string = "L7OK"

	// HTTPCheckRuleOkStatusL7OKC captures enum value "L7OKC"
	HTTPCheckRuleOkStatusL7OKC string = "L7OKC"

	// HTTPCheckRuleOkStatusL6OK captures enum value "L6OK"
	HTTPCheckRuleOkStatusL6OK string = "L6OK"

	// HTTPCheckRuleOkStatusL4OK captures enum value "L4OK"
	HTTPCheckRuleOkStatusL4OK string = "L4OK"
)

// prop value enum
func (m *HTTPCheckRule) validateOkStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, httpCheckRuleTypeOkStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *HTTPCheckRule) validateOkStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.OkStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateOkStatusEnum("ok_status", "body", m.OkStatus); err != nil {
		return err
	}

	return nil
}

func (m *HTTPCheckRule) validatePort(formats strfmt.Registry) error {
	if swag.IsZero(m.Port) { // not required
		return nil
	}

	if err := validate.MinimumInt("port", "body", *m.Port, 1, false); err != nil {
		return err
	}

	if err := validate.MaximumInt("port", "body", *m.Port, 65535, false); err != nil {
		return err
	}

	return nil
}

var httpCheckRuleTypeToutStatusPropEnum []interface{}

func init() {
	var res []string
	if err := json.Unmarshal([]byte(`["L7TOUT","L6TOUT","L4TOUT"]`), &res); err != nil {
		panic(err)
	}
	for _, v := range res {
		httpCheckRuleTypeToutStatusPropEnum = append(httpCheckRuleTypeToutStatusPropEnum, v)
	}
}

const (

	// HTTPCheckRuleToutStatusL7TOUT captures enum value "L7TOUT"
	HTTPCheckRuleToutStatusL7TOUT string = "L7TOUT"

	// HTTPCheckRuleToutStatusL6TOUT captures enum value "L6TOUT"
	HTTPCheckRuleToutStatusL6TOUT string = "L6TOUT"

	// HTTPCheckRuleToutStatusL4TOUT captures enum value "L4TOUT"
	HTTPCheckRuleToutStatusL4TOUT string = "L4TOUT"
)

// prop value enum
func (m *HTTPCheckRule) validateToutStatusEnum(path, location string, value string) error {
	if err := validate.EnumCase(path, location, value, httpCheckRuleTypeToutStatusPropEnum, true); err != nil {
		return err
	}
	return nil
}

func (m *HTTPCheckRule) validateToutStatus(formats strfmt.Registry) error {
	if swag.IsZero(m.ToutStatus) { // not required
		return nil
	}

	// value enum
	if err := m.validateToutStatusEnum("tout_status", "body", m.ToutStatus); err != nil {
		return err
	}

	return nil
}

func (m *HTTPCheckRule) validateVarName(formats strfmt.Registry) error {
	if swag.IsZero(m.VarName) { // not required
		return nil
	}

	if err := validate.Pattern("var_name", "body", m.VarName, `^[^\s]+$`); err != nil {
		return err
	}

	return nil
}

func (m *HTTPCheckRule) validateVarScope(formats strfmt.Registry) error {
	if swag.IsZero(m.VarScope) { // not required
		return nil
	}

	if err := validate.Pattern("var_scope", "body", m.VarScope, `^[^\s]+$`); err != nil {
		return err
	}

	return nil
}

// ContextValidate validate this http check rule based on the context it is used
func (m *HTTPCheckRule) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	var res []error

	if err := m.contextValidateCheckHeaders(ctx, formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *HTTPCheckRule) contextValidateCheckHeaders(ctx context.Context, formats strfmt.Registry) error {

	for i := 0; i < len(m.CheckHeaders); i++ {

		if m.CheckHeaders[i] != nil {
			if err := m.CheckHeaders[i].ContextValidate(ctx, formats); err != nil {
				if ve, ok := err.(*errors.Validation); ok {
					return ve.ValidateName("headers" + "." + strconv.Itoa(i))
				} else if ce, ok := err.(*errors.CompositeError); ok {
					return ce.ValidateName("headers" + "." + strconv.Itoa(i))
				}
				return err
			}
		}

	}

	return nil
}

// MarshalBinary interface implementation
func (m *HTTPCheckRule) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *HTTPCheckRule) UnmarshalBinary(b []byte) error {
	var res HTTPCheckRule
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}

// CheckHeader check header
//
// swagger:model CheckHeader
type CheckHeader struct {

	// name
	// Required: true
	Name *string `json:"name"`

	// value
	// Required: true
	Value *string `json:"value"`
}

// Validate validates this check header
func (m *CheckHeader) Validate(formats strfmt.Registry) error {
	var res []error

	if err := m.validateName(formats); err != nil {
		res = append(res, err)
	}

	if err := m.validateValue(formats); err != nil {
		res = append(res, err)
	}

	if len(res) > 0 {
		return errors.CompositeValidationError(res...)
	}
	return nil
}

func (m *CheckHeader) validateName(formats strfmt.Registry) error {

	if err := validate.Required("name", "body", m.Name); err != nil {
		return err
	}

	return nil
}

func (m *CheckHeader) validateValue(formats strfmt.Registry) error {

	if err := validate.Required("value", "body", m.Value); err != nil {
		return err
	}

	return nil
}

// ContextValidate validates this check header based on context it is used
func (m *CheckHeader) ContextValidate(ctx context.Context, formats strfmt.Registry) error {
	return nil
}

// MarshalBinary interface implementation
func (m *CheckHeader) MarshalBinary() ([]byte, error) {
	if m == nil {
		return nil, nil
	}
	return swag.WriteJSON(m)
}

// UnmarshalBinary interface implementation
func (m *CheckHeader) UnmarshalBinary(b []byte) error {
	var res CheckHeader
	if err := swag.ReadJSON(b, &res); err != nil {
		return err
	}
	*m = res
	return nil
}
